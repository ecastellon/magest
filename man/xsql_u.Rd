% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mp.r
\name{xsql_u}
\alias{xsql_u}
\title{SQL union}
\usage{
xsql_u(x = character(), idc = seq_along(x), cid = "con", all = TRUE)
}
\arguments{
\item{x}{character: vector con las expresiones SQL}

\item{idc}{character o numeric: sus elementos sirven para etiquetar
los resultados de cada consulta. Es opcional; por omisión,
secuencia de enteros de longitud igual a la de x}

\item{cid}{character: nombre de la columna del conjunto de datos,
que alojará las etiquetas de las consultas. Es opcional; por
omisión, "con"}

\item{all}{logical: \code{union all}?; TRUE por omisión}
}
\value{
character
}
\description{
Construye la expresión SQL "union"
}
\details{
Con «union» se juntan (al modo de un \code{rbind}) en un
solo conjunto de datos los resultados de varias consultas que
producen columnas respectivas del mismo tipo. Para identificar
en el resultado final los registros obtenidos con cada
consulta, se puede agregar a cada una un campo de valor
"constante", el cual aparecerá en el data.frame cuando se mande
ejecutar la consulta. La función brinda esa facilidad por medio
de los parámetros "idc" y "cid"

\if{html}{\out{<div class="sourceCode">}}\preformatted{La expresión «union» tiene dos variantes: «union» que no
devuelve registros que se repiten, y «union all» que incluye a
todos.
}\if{html}{\out{</div>}}
}
\examples{
cn <- c("select x, y from tx where y = 'a'",
        "select x, z from tx where z = 'b'")
xsql_u(cn, idc = c(1, 2), cid = "set")
#-> "select x, y, set = 1 from tx where y = 'a' union all(...
     select x, z, set = 2 from tx where z = 'b')
# todos los registros que produzca la primera consulta llevarán
# "1" en la columna "set" del data.frame que resulte de hacer la
# consulta a la base de datos, y todos los producidos por la segunda
# llevarán "2". Se supone que "y" y "z" son de igual tipo.
}
\seealso{
xsql_t
}
