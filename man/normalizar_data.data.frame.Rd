% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ut.r
\name{normalizar_data.data.frame}
\alias{normalizar_data.data.frame}
\title{Normalizar data.frame}
\usage{
\method{normalizar_data}{data.frame}(df, col_id, vbl = character())
}
\arguments{
\item{df}{data.frame}

\item{col_id}{numeric: columna con el índice (id) de los datos}

\item{vbl}{character: nombre de las variables del data.frame
resultado}
}
\value{
data.frame
}
\description{
Normaliza un data.frame que tiene datos de la misma
variable en diferentes columnas
}
\details{
En la documentación de la librería «tidyr» y en el
artículo de H.Wickham ahí referido, se discuten varios casos de
tablas de datos no normalizadas. Uno que es frecuente, es
cuando en la misma unidad de información (unidad de muestreo,
en las encuestas) se mide la misma variable en diferentes
fechas o en distintas partes de la unidad, como es el caso, en
las encuestas agrícolas, cuando en la misma finca se anotan las
superficies sembradas de diferentes cultivos. En tales casos se
puede terminar con una tabla de datos como la siguiente:\preformatted{quest c231 c234 c451 c454
10500    1    2    2    3
10510    0    0    2    6

donde la columna quest trae los datos del «id» de la finca,
c234 y c451 los datos del cultivo, y c234 y c454 las manzanas
sembradas de los cultivos en cuestión. En realidad sólo hay dos
variables: «cultivo» y «sembrada». Uno de los problemas con la
falta de normalización es que la tabla puede llevar muchos
datos «basura», como son (en el ejemplo) las dos primeras
columnas de la segunda fila.

La tabla normalizada luciría como se muestra adelante. Ahí ya
se ve la economía de almacenamiento: 9 datos en lugar de los 10
en la no normalizada

quest cultivo sembrada
10500       1        2
10500       2        3
10510       2        6

En la librería ya existe una función que devuelve la expresión
SQL que produce una tabla normalizada cuando se leen los
datos: «xsql_t»
}
}
\examples{
x <- data.frame(q = 1:4, a = sample(1:4), b = sample(2 * (1:4)),
                d = sample(3 * 1:4), e = sample(2 * (1:4)))
normalizar_data(x, 1, c("xx", "yy"))
}
\seealso{
xsql_t
}
